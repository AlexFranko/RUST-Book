## Невідновлювані помилки з `panic!`

Інколи у вашому коді відбуваються погані речі і ви нічого з цим не можете зробити. 
Для таких випадків Rust має для вас макрос `panic!`. Є загалом два способи викликати 
помилкову ситуацію (т.з. паніку) на практиці: якщо у виконуваному коді є дії, що 
призводить до паніки (наприклад звернення до елементу масиву за його межами) або 
викликаючи явно макрокоманду `panic!`. В обох випадках ми отримаємо паніку у нашій 
програмі. По замовчування, ці паніки будуть виводити повідомлення про помилку, 
також перерветься виконання, очиститься стек і програма завершить своє виконання. 
За допомогою змінних середовища, ви також можете вивести стек викликів, коли виникає 
паніка, щоб простіше відслідкувати причину такої ситуації.

> ### Розгортання по стеку чи переривання роботи у відповідь на паніку
>
> По замовчування, коли відбувається паніка, програма починає *розгортатися*, тобто
> Rust йде вгору по стеку викликів і очищає дані кожної функції, яка викликалась.
> Однак, такий підхід вимагає багато роботи, тому Rust дозволяє також вибрати альтернативу
> у вигляді негайного *переривання* виконання, який завершує програму без очищення.
>
> Пам'ять, яку використовувала програма згодом буде очищеною операційною системою. 
> Якщо у вашому проекті потрібно зробити зібраний двійковий файл якомога меншого розміру,
> ви можете перемкнутися з розгортання на переривання у випадку паніки, додавши 
> `panic = 'abort'` у відповідній `[profile]` секції у вашому  *Cargo.toml* файлі.
> Для прикладу, якщо ви хочете ввімкнути переривання, коли виникає паніка 
> в релізному режимі, тоді додайте:
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```

Давайте спробуємо викликати `panic!` у простій програмі:

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-01-panic/src/main.rs}}
```

Коли в запустите програму, то маєте побачити щось схоже на це:

```console
{{#include ../listings/ch09-error-handling/no-listing-01-panic/output.txt}}
```

Виклик макросу `panic!` призводить до появи повідомлення про помилку, 
що містить пояснення в останніх двох рядках. Перший рядок показує повідомлення 
про помилку і місце в коді, де паніка виникла: *src/main.rs:2:5* показує, 
що це другий рядок, п'ятий символ у файлі *src/main.rs*.

В даному випадку вказаний рядок є частиною коду, і якщо ми перейдемо до цього рядка, 
то зможемо побачити виклик `panic!` макросу. В іншому випадку виклик `panic!` макросу 
може знаходитись в коді, який викликає наш код, а ім'я файлу і номер рядка в повідомленні 
про помилку можуть вказувати на код когось іншого, де макрос `panic!` був викликаний, 
а не той номер рядку нашого коду, який в результаті призвів до виклику макросу. 
Ми можемо використати зворотнє трасування функції, з якої прийшов виклик макросу `panic!`, 
щоб вияснити яка частина нашого коду є причиною цієї проблеми. Далі ми детальніше 
розглянемо поняття зворотнього трасування.

### Використання зворотнього трасування при виклику `panic!` макросу

Давайте розглянемо інший приклад, щоб зрозуміти, що відбувається, коли виклик макросу 
`panic!` відбувається не з нашого коду, який викликає його напряму, а з бібліотеки в 
зв'язку з помилкою у нашому коді. У роздруку 9-1 написаний код, який намагається 
взяти елемент масиву у векторі по індексу, який виходить за межі допустимого діапазону 
значень індексу.

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-01/src/main.rs}}
```

<span class="caption">Роздрук 9-1: Спроба звернутися до елементу за межами вектору,
що призведе до виклику макросу `panic!`</span>

Тут ми ми намагаємось отримати доступ до 100-го елементу вектора (який знаходиться під 
індексом 99, оскільки індексація починається з нуля), але вектор містить тільки 3 
елементи. В цьому випадку Rust буде в стані паніки. Використання `[]` ймовірно має 
повертати елемент, але, якщо передається недопустимий індекс, то немає жодного елемента,
який Rust зміг би повернути.

В мові програмування C, доступ по індексу поза допустимими межами структури даних є 
невизначеною поведінкою. Ви можете отримати що завгодно, що знаходиться у цій ділянці 
пам'яті, яка відповідає такому елементу у структурі даних. Це називається *переповненням 
буферу* і може призводити до вразливостей в системі безпеки, якщо зловмисник зможе 
маніпулювати індексом таким чином, щоб зчитувати дані, які зберігаються за межами 
масиву і не повинні бути доступними для читання.

В цілях захисту програми від такого роду вразливостей, якщо ви будете намагатися 
прочитати елемент з недопустимим індексом, Rust зупинить виконання і відмовиться далі 
виконувати програму. давайте спробуємо і побачимо це наочно:

```console
{{#include ../listings/ch09-error-handling/listing-09-01/output.txt}}
```

Ця помилка вказує на рядок 4 нашого файлу `main.rs` де ми намагаємося отримати 
доступ до елементу під індексом 99. Наступний рядок говорить нам встановити 
`RUST_BACKTRACE` змінну середовища, щоб отримати зворотнє трасування того, що 
насправді стало причиною помилки. *Зворотнє трасування* - це список усіх функцій, 
які були викликані щоб дійти до цього моменту. Зворотні трасування в Rust працюють 
так само як і в інших мовах програмування. Ключовим моментом у читанні зворотнього 
трасування є те, що потрібно починати читати з зверху і до моменту, коли побачите 
файли, які ви написали. Саме це і буде тим місцем, де виникла проблема. Інші рядки, які
вище над рядками зі згадуванням наших файлів, це код, який викликається нашим кодом, а 
рядки нижче є кодом, який викликає наш код. Ці рядки можуть включати вбудований в Rust 
код, код стандартної бібліотеки або код використаних крейтів. Давайте спробуємо 
отримати зворотнє трасування через встановлення змінної середовища `RUST_BACKTRACE` у 
будь-яке значення, окрім 0. Роздрук 9-2 показує вивід аналогічний тому, що можете 
отримати ви.

<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->

```console
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/std/src/panicking.rs:483
   1: core::panicking::panic_fmt
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:85
   2: core::panicking::panic_bounds_check
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:62
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:255
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:15
   5: <alloc::vec::Vec<T> as core::ops::index::Index<I>>::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/alloc/src/vec.rs:1982
   6: panic::main
             at ./src/main.rs:4
   7: core::ops::function::FnOnce::call_once
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/ops/function.rs:227
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```

<span class="caption">Роздрук 9-2: Зворотнє трасування спричинене викликом
`panic!`, коли встановлена змінна середовища `RUST_BACKTRACE`</span>

Тут насправді багато виводу! Вивід, який ви бачите, може відрізнятися в залежності 
від операційної системи і версії Rust. Для того, щоб отримати зворотнє трасування з цією 
інформацією, мають бути ввімкнутими символи налагодження. Символи налагодження 
ввімкнуті по замовчуванні коли використовуємо команди `cargo build` або `cargo run` 
без додаткового прапорця `--release`, як було в нашому прикладі.

У виводі роздруку 9-2 рядок 6 вказує на рядок в нашому проекті, який викликав проблему: 
рядок 4 файлу  *src/main.rs*. Якщо ми не хочемо, щоб наша програма панікувала, ми 
повинні почати дослідження з місця, на яке вказує перший рядок зі згадуванням нашого фалу.
В роздруку, де ми для демонстрації зворотнього трасування спеціально написали код, який 
призводить до паніки, тому способом виправлення паніки буде в тому, щоб не намагатися 
отримати елемент за допустимими межами індексів вектора. Коли ваш код згенерує паніку 
в майбутньому, тоді слід вирішити, яка саме дія в коді і з яким значенням здійснила 
паніку і що код повинен робити насправді замість цього.

Ми повернемось до обговорення макросу `panic!` і того коли нам варто його використовувати 
і коли не слід для обробки помилок у розділі [“To `panic!` or Not to
`panic!`”][to-panic-or-not-to-panic]<!-- ignore --> далі у цій главі. Далі ми розглянемо, як відновити виконання програми після помилок, які можливо виправити, що використовують 
тип `Result`.

[to-panic-or-not-to-panic]:
ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic
